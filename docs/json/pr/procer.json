{"gems":{"name":"procer","downloads":393,"version":"0.1.1","version_created_at":"2023-03-05T12:37:27.515Z","version_downloads":20,"platform":"ruby","authors":"Jesús Gómez","info":"# Procer\n\n**NOTE: Experimental. Use it to experience what a default `to_proc`\ncould have been. For production code, I recommend an explicit\ntransformation, like the one provided by the gem `jgomo3-func`**.\n\nA reasonable good default `to_proc` method for all objects.\n\nInstall with:\n\n```\ngem install procer\n```\n\nWhen you require Procer, all objects will have a default `to_proc`\nmethod which will try to call one of the following methods, in the\ngiven order:\n\n - `call`\n - `[]`\n - `===`\n \n Many methods which receive a block, can benefit greatly from this\n because you can now pass an object to perform the block role.\n \n Think of the Enumerable module and all its methods.\n \n Many objects define `===`, but not `to_proc`. So they will be nicely\n usable in a `case/when` expression, but not in other contexts.\n \n This is the case of classes and ranges, which you can use in\n `case/when` expressions, but they don't define `to_proc`.\n \n Now they do define `to_proc` so they are useful in those contexts.\n \n Examples:\n \n ```ruby\n require 'procer'\n \n[1, 2, '3', '4', 5, 6].filter(&Numeric)\n# => [1, 2, 5, 6]\n\n[-10, 100, -2, 3, 20, -33].filter(&(0..50))\n# => [3, 20]\n```\n\nAlso, Hashes already implement `to_proc` and that is useful\nwith Enumerator. We can use it as a transformation table with `map`:\n\n```ruby\n\ntable = {\n  1 => 'one',\n  2 => 'two',\n  3 => 'three'\n}\n\n[3, 1, 2].map(&table)\n# => ['three, 'one, 'two']\n```\n\nSadly, Arrays, even when they have the same interface as hashes as a\nfunction of indices, don't implement `to_proc` and so they can't be used\nin the same way. Until now.\n\n```ruby\ntable = ['zero', 'one', 'two']\n[2, 0, 1].map(&table)\n# => ['two', 'zero', 'one']\n```\n\nAlternatively, you could have used `values_at`:\n\n```ruby\ntable.values_at([3, 1, 2]) # In the Hash example\ntable.values_at([2, 0, 1]) # In the Array example\n```\n\nBut the map solution is more generic and `table` can be anything that\nimplements `to_proc` and not something that necessarily implements\n`values_at`.\n\nNotice that if the object implements `[]` that will triumph over\n`===`.  It was unexpected when I tried to use Integers as the object, as\nthey implement `[]` as a way to access their binary form:\n\n```ruby\n5 # b101\n[5[2], 5[1], 5[0]] # [1, 0, 1]\n```\n\nSo the proc will work like that:\n\n```ruby\n[2, 4, 5].map(&5)\n# Actual => [1, 0, 0]\n# I was expecting => [false, false, true]\n```\n","licenses":["MIT"],"metadata":{"Intended Audience :: Developers":"classifier","Intended Audience :: Programmers":"classifier","Topic :: Programming :: Experimental":"classifier"},"yanked":false,"sha":"401c17c5568b43d4f0318c9e2f12879abff97fb52da501d427d540560f382f42","project_uri":"https://rubygems.org/gems/procer","gem_uri":"https://rubygems.org/gems/procer-0.1.1.gem","homepage_uri":"https://github.com/jgomo3/procer/","wiki_uri":null,"documentation_uri":"https://www.rubydoc.info/gems/procer/0.1.1","mailing_list_uri":null,"source_code_uri":null,"bug_tracker_uri":null,"changelog_uri":null,"funding_uri":null,"dependencies":{"development":[],"runtime":[]}},"vcs_name":"GitHub","ci":null,"vcs_uri":"https://github.com/jgomo3/procer/"}