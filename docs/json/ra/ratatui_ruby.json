{"gems":{"name":"ratatui_ruby","downloads":8040,"version":"1.4.0","version_created_at":"2026-02-16T01:17:56.079Z","version_downloads":5,"platform":"x64-mingw-ucrt","authors":"Kerrick Long","info":"\n== Terminal UIs, the Ruby Way\n\nRatatuiRuby[https://rubygems.org/gems/ratatui_ruby] is a RubyGem built on\nRatatui[https://ratatui.rs], a leading TUI library written in\nRust[https://rust-lang.org]. You get native performance with the joy of Ruby.\n\n  gem install ratatui_ruby\n\n{rdoc-image:https://ratatui-ruby.dev/hero.gif}[https://www.ratatui-ruby.dev/docs/v0.10/examples/app_cli_rich_moments/README_md.html]\n\n=== Rich Moments\n\nAdd a spinner, a progress bar, or an inline menu to your CLI script. No\nfull-screen takeover. Your terminal history stays intact.\n\n==== Inline Viewports\n\nStandard TUIs erase themselves on exit. Your carefully formatted CLI output\ndisappears. Users lose their scrollback.\n\n<b>Inline viewports</b> solve this. They occupy a fixed number of lines, render\nrich UI, then leave the output in place when done.\n\nPerfect for spinners, menus, progress indicators—any brief moment of richness.\n\n  require \"ratatui_ruby\"\n\n  RatatuiRuby.run(viewport: :inline, height: 1) do |tui|\n    until connected?\n      status = tui.paragraph(text: \"\\#{spin} Connecting...\")\n      tui.draw { |frame| frame.render_widget(status, frame.area) }\n    end\n  end\n\n=== Build Something Real\n\nFull-screen applications with {keyboard and mouse input}[https://www.ratatui-ruby.dev/docs/v0.10/examples/app_all_events/README_md.html]. The managed loop\nsets up the terminal and restores it on exit, even after crashes.\n\n  RatatuiRuby.run do |tui|\n    loop do\n      tui.draw do |frame|\n        frame.render_widget(\n          tui.paragraph(text: \"Hello, RatatuiRuby!\", alignment: :center),\n          frame.area\n        )\n      end\n\n      case tui.poll_event\n      in { type: :key, code: \"q\" } then break\n      else nil\n      end\n    end\n  end\n\n==== Widgets included:\n\n[Layout]\n  {Block}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_block/README_md.html],\n  {Center}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_center/README_md.html],\n  {Clear (Popup, Modal)}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_popup/README_md.html],\n  {Layout (Split, Grid)}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_layout_split/README_md.html],\n  {Overlay}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_overlay/README_md.html]\n[Data]\n  {Bar Chart}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_barchart/README_md.html],\n  {Chart}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_chart/README_md.html],\n  {Gauge}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_gauge/README_md.html],\n  {Line Gauge}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_line_gauge/README_md.html],\n  {Sparkline}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_sparkline/README_md.html],\n  {Table}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_table/README_md.html]\n[Text]\n  {Cell}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_cell/README_md.html],\n  {List}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_list/README_md.html],\n  {Rich Text (Line, Span)}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_rich_text/README_md.html],\n  {Scrollbar (Scroll)}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_scrollbar/README_md.html],\n  {Tabs}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_tabs/README_md.html]\n[Graphics]\n  {Calendar}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_calendar/README_md.html],\n  {Canvas}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_canvas/README_md.html],\n  {Map (World Map)}[https://www.ratatui-ruby.dev/docs/v0.10/examples/widget_map/README_md.html]\n\nNeed something else? {Build custom widgets}[https://www.ratatui-ruby.dev/docs/v0.10/doc/concepts/custom_widgets_md.html] in Ruby!\n\n\n---\n\n=== Testing Built In\n\nTUI testing is tedious. You need a headless terminal, event injection,\nsnapshot comparisons, and style assertions. RatatuiRuby bundles all of it.\n\n  require \"ratatui_ruby/test_helper\"\n\n  class TestColorPicker < Minitest::Test\n    include RatatuiRuby::TestHelper\n\n    def test_swatch_widget\n      with_test_terminal(10, 3) do\n        RatatuiRuby.draw do |frame|\n          frame.render_widget(Swatch.new(:red), frame.area)\n        end\n        assert_cell_style 2, 1, char: \"█\", bg: :red\n      end\n    end\n  end\n\n==== What's inside:\n\n- <b>Headless terminal</b> — No real TTY needed\n- <b>Snapshots</b> — Plain text and rich (ANSI colors)\n- <b>Event injection</b> — Keys, mouse, paste, resize\n- <b>Style assertions</b> — Color, bold, underline at any cell\n- <b>Test doubles</b> — Mock frames and stub rects\n- <b>UPDATE_SNAPSHOTS=1</b> — Regenerate baselines in one command\n\n\n---\n\n==== Inline Menu Example\n\n  require \"ratatui_ruby\"\n\n  # This example renders an inline menu. Arrow keys select, enter confirms.\n  # The menu appears in-place, preserving scrollback. When the user chooses,\n  # the TUI closes and the script continues with the selected value.\n  class RadioMenu\n    CHOICES = [\"Production\", \"Staging\", \"Development\"]         # ASCII strings are universally supported.\n    PREFIXES = { active: \"●\", inactive: \"○\" }                  # Some terminals may not support Unicode.\n    CONTROLS = \"↑/↓: Select | Enter: Choose | Ctrl+C: Cancel\"  # Let users know what keys you handle.\n    TITLES = [\"Select Environment\",                            # The default title position is top left.\n              { content: CONTROLS,                             # Multiple titles can save space.\n                position: :bottom,                             # Titles go on the top or bottom,\n                alignment: :right }]                           # aligned left, right, or center\n\n    def call                                                   # This method blocks until a choice is made.\n      RatatuiRuby.run(viewport: :inline, height: 5) do |tui|   # RatauiRuby.run manages the terminal.\n        @tui = tui                                             # The TUI instance is safe to store.\n        show_menu until chosen?                                # You can use any loop keyword you like.\n      end                                                      # `run` won't return until your block does,\n      RadioMenu::CHOICES[@choice]                              # so you can use it synchronously.\n    end\n                                                               # Classes like RadioMenu are convenient for\n    private                                                    # CLI authors to offer \"rich moments.\"\n\n    def show_menu = @tui.draw do |frame|                       # RatatuiRuby gives you low-level access.\n      widget = @tui.paragraph(                                 # But the TUI facade makes it easy to use.\n        text: menu_items,                                      # Text can be spans, lines, or paragraphs.\n        block: @tui.block(borders: :all, titles: TITLES)       # Blocks give you boxes and titles, and hold\n      )                                                        # one or more widgets. We only use one here,\n      frame.render_widget(widget, frame.area)                  # but \"area\" lets you compose sub-views.\n    end\n\n    def chosen?                                                # You are responsible for handling input.\n      interaction = @tui.poll_event                            # Every frame, you receive an event object:\n      return choose if interaction.enter?                      # Key, Mouse, Resize, Paste, FocusGained,\n                                                               # FocusLost, or None objects. They come with\n      move_by(-1) if interaction.up?                           # predicates, support pattern matching, and\n      move_by(1) if interaction.down?                          # can be inspected for properties directly.\n      quit! if interaction.ctrl_c?                             # Your application must handle every input,\n      false                                                    # even interrupts and other exit patterns.\n    end\n\n    def choose                                                 # Here, the loop is about to exit, and the\n      prepare_next_line                                        # block will return. The inline viewport\n      @choice                                                  # will be torn down and the terminal will\n    end                                                        # be restored, but you are responsible for\n                                                               # positioning the cursor.\n    def prepare_next_line                                      # To ensure the next output is on a new\n      area = @tui.viewport_area                                # line, query the viewport area and move\n      RatatuiRuby.cursor_position = [0, area.y + area.height]  # the cursor to the start of the last line.\n      puts                                                     # Then print a newline.\n    end\n\n    def quit!                                                  # All of your familiar Ruby control flow\n      prepare_next_line                                        # keywords work as expected, so we can\n      exit 0                                                   # use them to leave the TUI.\n    end\n\n    def move_by(line_count)                                    # You are in full control of your UX, so\n      @choice = (@choice + line_count) % CHOICES.size          # you can implement any logic you need:\n    end                                                        # Would you \"wrap around\" here, or not?\n                                                               #\n    def menu_items = CHOICES.map.with_index do |choice, i|     # Notably, RatatuiRuby has no concept of\n      \"\\#{prefix_for(i)} \\#{choice}\"                             # \"menus\" or \"radio buttons\". You are in\n    end                                                        # full control, but it also means you must\n    def prefix_for(choice_index)                               # implement the logic yourself. For larger\n      return PREFIXES[:active] if choice_index == @choice      # applications, consider using Rooibos,\n      PREFIXES[:inactive]                                      # an MVU framework built with RatatuiRuby.\n    end                                                        # Or, use the upcoming ratatui-ruby-kit,\n                                                               # our object-oriented component library.\n    def initialize = @choice = 0                               # However, those are both optional, and\n  end                                                          # designed for full-screen Terminal UIs.\n                                                               # RatatuiRuby will always give you the most\n  choice = RadioMenu.new.call                                  # control, and is enough for \"rich CLI\n  puts \"You chose \\#{choice}!\"                                  # moments\" like this one.\n\n---\n\n=== Full App Solutions\n\nRatatuiRuby renders. For complex applications, add a framework that manages\nstate and composition.\n\n==== Rooibos[https://www.rooibos.run] (Framework)\n\nModel-View-Update architecture. Inspired by Elm, Bubble Tea, and React +\nRedux. Your UI is a pure function of state.\n\n- Functional programming with MVU\n- Commands work off the main thread\n- Messages, not callbacks, drive updates\n\n==== {Kit}[https://sr.ht/~kerrick/ratatui_ruby/#chapter-3-the-object-path--kit] (Coming Soon)\n\nComponent-based architecture. Encapsulate state, input handling, and\nrendering in reusable pieces.\n\n- OOP with stateful components\n- Separate UI state from domain logic\n- Built-in focus management & click handling\n\nBoth use the same widget library and rendering engine. Pick the paradigm\nthat fits your brain.\n\n\n---\n\n=== Why RatatuiRuby?\n\nRuby deserves world-class terminal user interfaces. TUI developers deserve\na world-class language.\n\nRatatuiRuby wraps Rust's Ratatui via native extension. The Rust library\nhandles rendering. Your Ruby code handles design.\n\n>>>\n  \"Text UIs are seeing a renaissance with many new TUI libraries popping up.\n  The Ratatui bindings have proven to be full featured and stable.\"\n\n  — {Mike Perham}[https://www.mikeperham.com/], creator of\n  Sidekiq[https://sidekiq.org/] and Faktory[https://contribsys.com/faktory/]\n\n==== Why Rust? Why Ruby?\n\nRust excels at low-level rendering. Ruby excels at expressing domain logic\nand UI. RatatuiRuby puts each language where it performs best.\n\n==== Versus CharmRuby\n\nCharmRuby[https://charm-ruby.dev/] wraps Charm's Go libraries. Both projects\ngive Ruby developers TUI options.\n\n[Integration]\n  CharmRuby: Two runtimes, one process.\n  RatatuiRuby: Native extension in Rust.\n[Runtime]\n  CharmRuby: Go + Ruby (competing).\n  RatatuiRuby: Ruby (Rust has no runtime).\n[Memory]\n  CharmRuby: Two uncoordinated GCs.\n  RatatuiRuby: One Garbage Collector.\n[Style]\n  CharmRuby: The Elm Architecture (TEA).\n  RatatuiRuby: TEA, OOP, or Imperative.\n\n\n---\n\n=== Links\n\n[Get Started]\n  {Quickstart}[https://www.ratatui-ruby.dev/docs/v0.10/doc/getting_started/quickstart_md.html],\n  {Examples}[https://www.ratatui-ruby.dev/docs/v0.10/examples/app_cli_rich_moments/README_md.html],\n  {API Reference}[https://www.ratatui-ruby.dev/docs/v0.10/],\n  {Guides}[https://www.ratatui-ruby.dev/docs/v0.10/doc/index_md.html]\n[Ecosystem]\n  Rooibos[https://www.rooibos.run],\n  {Kit}[https://sr.ht/~kerrick/ratatui_ruby/#chapter-3-the-object-path--kit] (Planned),\n  {Framework}[https://sr.ht/~kerrick/ratatui_ruby/#chapter-5-the-framework] (Planned),\n  {UI Widgets}[https://sr.ht/~kerrick/ratatui_ruby/#chapter-6-licensing] (Planned)\n[Community]\n  {Forum}[https://forum.setdef.com/c/ratatui-ruby/6],\n  {Announcements}[https://forum.setdef.com/tags/c/ratatui-ruby/6/announcement],\n  {Discussion}[https://forum.setdef.com/tags/c/ratatui-ruby/6/discussion],\n  {Bug Tracker}[https://forum.setdef.com/tags/c/ratatui-ruby/6/bug]\n[Contribute]\n  {Contributing Guide}[https://man.sr.ht/~kerrick/ratatui_ruby/contributing.md],\n  {Code of Conduct}[https://man.sr.ht/~kerrick/ratatui_ruby/code_of_conduct.md],\n  {Project History}[https://man.sr.ht/~kerrick/ratatui_ruby/history/index.md],\n  {Pull Requests}[https://forum.setdef.com/tags/c/ratatui-ruby/6/patch]\n\n\n---\n\n[Website] https://www.ratatui-ruby.dev\n[Source] https://github.com/setdef/RatatuiRuby\n[RubyGems] https://rubygems.org/gems/ratatui_ruby\n[Upstream] https://ratatui.rs\n[Build Status] https://builds.sr.ht/~kerrick/ratatui_ruby\n\n© 2026 Kerrick Long · Library: LGPL-3.0-or-later · Website: CC-BY-NC-ND-4.0 · Snippets: MIT-0","licenses":["LGPL-3.0-or-later"],"metadata":{"wiki_uri":"https://man.sr.ht/~kerrick/ratatui_ruby/","funding_uri":"https://opencollective.com/ratatui","homepage_uri":"https://www.ratatui-ruby.dev","changelog_uri":"https://github.com/setdef/RatatuiRuby/blob/stable/CHANGELOG.md","bug_tracker_uri":"https://forum.setdef.com/tags/c/ratatui-ruby/6/bug","source_code_uri":"https://github.com/setdef/RatatuiRuby","mailing_list_uri":"https://forum.setdef.com/c/ratatui-ruby/6","allowed_push_host":"https://rubygems.org","documentation_uri":"https://www.ratatui-ruby.dev/docs/"},"yanked":false,"sha":"febcafd76da7979e674aaa5a48d2568f588393d6a1ed0c94ffb1cb95de9eb6a8","spec_sha":"6642426b3d2f78dee17b7f6c089f36e31728fd5029f7e97c562ae8c115ef9795","project_uri":"https://rubygems.org/gems/ratatui_ruby","gem_uri":"https://rubygems.org/gems/ratatui_ruby-1.4.0-x64-mingw-ucrt.gem","homepage_uri":"https://www.ratatui-ruby.dev","wiki_uri":"https://man.sr.ht/~kerrick/ratatui_ruby/","documentation_uri":"https://www.ratatui-ruby.dev/docs/","mailing_list_uri":"https://forum.setdef.com/c/ratatui-ruby/6","source_code_uri":"https://github.com/setdef/RatatuiRuby","bug_tracker_uri":"https://forum.setdef.com/tags/c/ratatui-ruby/6/bug","changelog_uri":"https://github.com/setdef/RatatuiRuby/blob/stable/CHANGELOG.md","funding_uri":"https://opencollective.com/ratatui","dependencies":{"development":[{"name":"debug","requirements":">= 1.0"},{"name":"faker","requirements":"~> 3.5.3"},{"name":"rake-compiler","requirements":"~> 1.2"},{"name":"rdoc","requirements":"~> 7.0"}],"runtime":[{"name":"rb_sys","requirements":"~> 0.9"},{"name":"rexml","requirements":"~> 3.4"}]}},"vcs_name":"GitHub","ci":1,"github_actions":1,"vcs_uri":"https://github.com/setdef/RatatuiRuby"}